
/**
 * @file    gpio.c
 * @brief   GPIO HAL for EFM32GG
 * @version 2.0
 * 
 * @note    This is a version 2 of the GPIO library. It implements support
 *          for interrupts.
 * 
 * @note    The GPIO architecture in the EFM32 series only enables one pin
 *          with a specific number to generate interrupts. For example, only
 *          one Px10 can generate an interrupt.
 *          
 * @note    There are two interrupts associated with the GPIOs.
 * 
 *          * GPIO_ODD_IRQHandler:  Generated by pins with odd numbers.
 *          * GPIO_EVEN_IRQHandler: Generated by pins with EVEN numbers.
 * 
 * @note    There are two registers (EXTIPSELL and EXTIPSELH), that specifies
 *          which GPIO port generates an interrupt. EXPTISELL specifies which 
 *          GPIO port generates interrupts for pins 0 to 7 and EXPTISELH, for 
 *          pins 8 to 15.
 * 
 * @note    Additionally, the register IEN specifies which pins can generate 
 *          interrupts. The registers EXTIRISE and EXTIFRALL enable interrupts
 *          when the signal on a pin rises or falls.
 * 
 * 
 */

#include <stdint.h>
#include "gpio.h"


#define BIT(N)          (1U<<(N))

/**
 * @brief callbacks routines
 * 
 * @note  A struct is used to enable the sharing of callback functions
 * 
 * @note  They are called when an interrupt is generated.
 * 
 * @note  There are 16 of them, one for each pin number.
 * 
 */
typedef struct {
    void (*callback)(uint32_t);
    GPIO_t gpio;
    uint32_t mask;
} CallbackInfo;

static CallbackInfo GPIO_Callback[16] = {0};

/**
 * @brief Find gpio port index
 *
 * @note  GPIO is referenced by a pointer, but sometimes it must be 
 *        referenced by an index. This functions returns the index
 *        cor 
 */
static inline int GPIO_FindIndex(GPIO_t gpio) {

    return gpio-GPIOA;

}

/**
 * @brief 
 * 
 * @param pin 
 * @return int 
 */
static inline int GPIO_EnableIRQ(int pin) {

    GPIO->IEN |= BIT(pin);

}

/**
 * @brief 
 * 
 * @param pin 
 * @return int 
 */
static inline int GPIO_DisableIRQ(int pin) {

    GPIO->IEN &= ~BIT(pin);

}

/**
 * @brief 
 * 
 * @param pin 
 * @return int 
 */
static inline int GPIO_ClearIRQ(int pin) {

    GPIO->IFC = BIT(pin);

}

/**
 * @brief   Configure pins
 * @param   gpio: pointer to gpio registers
 * @param   pins: bit mask containing 1 in the position to be configured
 * @param   mode: GPIO_MODE_INPUT, GPIO_MODE_PUSHPULL, etc.
 */

void
GPIO_ConfigPins(GPIO_t gpio, uint32_t pins, uint32_t mode) {
const uint32_t mask = 0xF;  // Fields are 4 bits wide
int i;
uint32_t mbit;


    mbit = 0x0001; // Bit 0 set
    /* Configure low order bits/pins  0-7 */
    for(i=0;i<32;i+=4) {
        if( (pins&mbit) != 0 ) {
            gpio->MODEL &= ~(mask<<i);
            gpio->MODEL |= mode<<i;
        }
        mbit <<= 1;
    }
    /* Configure High order bits/pins 8-15 */
    for(i=0;i<32;i+=4) {
        if( (pins&mbit) != 0 ) {
            gpio->MODEH &= ~(mask<<i);
            gpio->MODEH |= mode<<i;
        }
        mbit <<= 1;
    }

}

/**
 * @brief   Configure pins for input or output
 * @param   gpio:    pointer to gpio registers
 * @param   inputs:  bit mask containing 1 in the position to be configured as input
 * @param   outputs: bit mask containing 1 in the position to be configured as output
 */

void
GPIO_Init(GPIO_t gpio, uint32_t inputs, uint32_t outputs) {


    /* Enable Clock for GPIO */
    CMU->HFPERCLKDIV |= CMU_HFPERCLKDIV_HFPERCLKEN;     // Enable HFPERCLK
    CMU->HFPERCLKEN0 |= CMU_HFPERCLKEN0_GPIO;           // Enable HFPERCKL for GPIO

    GPIO_ConfigPins(gpio,outputs,GPIO_MODE_PUSHPULL);
    GPIO_ConfigPins(gpio,inputs,GPIO_MODE_INPUT);       // Safer when both specified

}

#define GPIO_IRQ_SENSE_RISING    1
#define GPIO_IRQ_SENSE_FALLING   2
#define GPIO_IRQ_SENSE_BOTH      (GPIO_IRQ_SENSE_RISING|GPIO_IRQ_SENSE_FALLING)

/**
 * @brief   Set IRQ routine
 * 
 * @param gpio 
 * @param pin 
 * @param callback 
 * @return int 
 */
int GPIO_SetIRQ(GPIO_t gpio, int pin, int sense, void (*callback)(uint32_t)) {
int index;
uint32_t m = BIT(pin);


    // Disable interrupt for pin
    GPIO->IEN &= ~m;

    // Set CallbackInfo struct for pin
    index = GPIO_FindIndex(gpio);
    GPIO_Callback[index].callback = callback;
    GPIO_Callback[index].mask     = m;
    GPIO_Callback[index].gpio     = gpio;

    // Configure sense
    if( (sense&GPIO_IRQ_SENSE_RISING)!=0 )  GPIO->EXTIRISE |= m;
    if( (sense&GPIO_IRQ_SENSE_FALLING)!=0 ) GPIO->EXTIFALL |= m;

    // Set which gpio will trigger interrupt
    if( index < 8 ) {
        GPIO->EXTIPSELL = (index<<(pin*4));
    } else {
        GPIO->EXTIPSELH = (index<<((pin-8)*4));
    }

    // Clear any interrupt from pin
    GPIO->IFC = m;

    // Enable interrupt for pin
    GPIO->IEN |= m;

    
    return 0;
}


/**
 * @brief 
 * 
 */
static void ProcessInterrupt(int pin) {
CallbackInfo *p = GPIO_Callback + pin;
uint32_t in;
GPIO_t gpio;

    // Get gpio port address
    if( !p->gpio )
        return;
    gpio = p->gpio;

    // Read Port
    in = gpio->DIN;

    // Clear interrupt
    GPIO->IFC = p->mask;

    // Call callback routine
    if( p->callback ) p->callback(in);

}

/**
 * @brief Interrupt routines
 * 
 * @note  Loop unrolled to make it faster
 */
///@{
void GPIO_ODD_IRQHandler(void) {
uint32_t ie;

    ie = GPIO->IF;
    if( (ie&BIT(1))!=0 )  ProcessInterrupt(1);
    if( (ie&BIT(3))!=0 )  ProcessInterrupt(3);
    if( (ie&BIT(5))!=0 )  ProcessInterrupt(5);
    if( (ie&BIT(7))!=0 )  ProcessInterrupt(7);
    if( (ie&BIT(9))!=0 )  ProcessInterrupt(9);
    if( (ie&BIT(11))!=0 ) ProcessInterrupt(11);
    if( (ie&BIT(13))!=0 ) ProcessInterrupt(13);
    if( (ie&BIT(15))!=0 ) ProcessInterrupt(15);

}

void GPIO_EVEN_IRQHandler(void) {
uint32_t ie;

    ie = GPIO->IF;
    if( (ie&BIT(0))!=0 )  ProcessInterrupt(0);
    if( (ie&BIT(2))!=0 )  ProcessInterrupt(2);
    if( (ie&BIT(4))!=0 )  ProcessInterrupt(4);
    if( (ie&BIT(6))!=0 )  ProcessInterrupt(6);
    if( (ie&BIT(8))!=0 )  ProcessInterrupt(8);
    if( (ie&BIT(10))!=0 ) ProcessInterrupt(10);
    if( (ie&BIT(12))!=0 ) ProcessInterrupt(12);
    if( (ie&BIT(14))!=0 ) ProcessInterrupt(14);

}
///@}