7  Processing inside the SysTick Interrupt
===========================================

This is the 7th version of Blink. It uses the same HAL for LEDs (STK3700). The main modification is the use a better way to control time.

In all examples shown, the delay between blink was controlled by a routine called Delay.

    void Delay(uint32_t delay) {
    volatile uint32_t counter;
    int i;
    
        for(i=0;i<delay;i++) {
            counter = 10000;
            while( counter ) counter--;
        }
    }

This form has two HUGE drawbacks:

1.  During this time, no work is done. This routine is just a waste of processor and energy.
2.  It is dependent on processor clock, and compiler. Code generated by different compilers lead to different delays.

A better way is to use a periodical interrupt. All Cortex M devices have a System Times (SysTick) peripheral.
It is a 24 bit counter. (beware, it is not 32 bits). It is basically controlled by two registers: SysTick Reload Value Register (RVR) and the SysTick Current Value Register (CVR). The Current Value Register counts downward until zero. Then it loads automatically the value stored in the Reload Value Register. Most implementations permit to choose different sources for
the clock signal, but the default is the Core Clock.

Using CMSIS it is easy to set the *SysTick* using the *SystemCoreClock* variable (contains the frequency of core). In the *startup_DEVICE.c* there is a weak definition of a *SysTick* Interrupt Handler. When a routine called *SysTick_Handler* is defined in other module, the weak definition is not used, and the pointer in the Interrupt Vector points to the newly defined *SysTick_Handler*.

    void SysTick_Handler(void) {
     ... processing of
    }
    ...
    (void) SysTickConfig(SystemCoreClock/1000); // Tick every millisecond
    ...

In the Cortex-M family an interrupt processing routine is a C function with no parameters and no return value. This is quite different from other architectures.

The structure of a program using interrupts is very different of the structure of sequential programs, like the former examples. Interrupts must be fast and so, it never should have a wait loop. Instead a sequence of actions, separated by delay calls, an interrupt routine must take a different action every time it is called. In order to take the correct action, the interrupt must have a state.

    void SysTick_Handler(void) {
    static int8_t state = 0; // must be static
    
        switch(state) {
        case 0:
            LED_Toggle(LED1);
            state = 1;
            break;
        case 1:
            LED_Toggle(LED2);
            state = 2;
            break;
        case 2:
            LED_Write(0,LED1|LED2);
            state = 0;
            break;
        }
    }
    
This can be represented by a very simple state machine.

But there is the fact that the SysTick counter is a 24 bit counter. It can counts from
2<sup>24</sup>-1=16.777.215 to 0. If the frequency of core clock is a little greater than 16 MHz, it is not possible to make the SysTick handler be called every second. The solution is to use a software divider.

    void SysTick_Handler(void) {
    static int counter = 0; // must be static
    
        if( counter != 0 ) {
            counter--;
        } else {
            // Processing
            ...
            counter = DIVIDER-1;
        }
    }
    
The processing part is then called once in every DIVIDER calls.
